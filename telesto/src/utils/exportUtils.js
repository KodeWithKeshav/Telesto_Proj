// Advanced export utilities for various geological and reservoir modeling formats

/**
 * Export geological data to CSV format
 */
export const exportToCSV = async (data, options) => {
  const { gridCells, wellPaths, horizonData, faultData, metadata } = data;
  const { includeHeaders, precision, includeProperties } = options;
  
  let csvContent = '';
  
  // Grid data export
  if (gridCells && gridCells.length > 0) {
    if (includeHeaders) {
      csvContent += '# Geological Grid Data\n';
      if (metadata) {
        csvContent += `# Export Date: ${metadata.exportDate}\n`;
        csvContent += `# Total Cells: ${metadata.totalCells}\n`;
        csvContent += `# Coordinate System: ${metadata.coordinateSystem}\n`;
        csvContent += `# Units: ${metadata.units}\n\n`;
      }
    }
    
    const headers = ['X', 'Y', 'Z', 'Layer'];
    if (includeProperties) {
      headers.push('Porosity', 'Permeability', 'Facies');
    }
    
    csvContent += headers.join(',') + '\n';
    
    gridCells.forEach(cell => {
      const row = [
        cell.x.toFixed(precision),
        cell.y.toFixed(precision),
        cell.z.toFixed(precision),
        cell.layer
      ];
      
      if (includeProperties) {
        row.push(
          cell.porosity?.toFixed(precision + 2) || '',
          cell.permeability?.toFixed(precision) || '',
          cell.facies || ''
        );
      }
      
      csvContent += row.join(',') + '\n';
    });
  }
  
  // Well data export
  if (wellPaths && wellPaths.length > 0) {
    csvContent += '\n# Well Path Data\n';
    csvContent += 'WellName,X,Y,Z,MD,TVD,Layer,Porosity,Permeability\n';
    
    wellPaths.forEach(well => {
      if (well.intersections) {
        well.intersections.forEach(point => {
          csvContent += [
            well.name,
            point.x.toFixed(precision),
            point.y.toFixed(precision),
            point.z.toFixed(precision),
            point.md.toFixed(precision),
            point.tvd.toFixed(precision),
            point.layer || '',
            point.porosity?.toFixed(precision + 2) || '',
            point.permeability?.toFixed(precision) || ''
          ].join(',') + '\n';
        });
      }
    });
  }
  
  return csvContent;
};

/**
 * Export data in Petrel ASCII format
 */
export const exportToPetrel = async (data, options) => {
  const { gridCells, horizonData } = data;
  const { precision } = options;
  
  let petrelContent = '';
  
  // Petrel header
  petrelContent += `# Petrel ASCII Export
# Generated by Telesto Geological Grid Generator
# Export Date: ${new Date().toISOString()}

# Grid Properties
BEGIN HEADER
  UNDEFINED -999.0
  COORD_SYS UTM
  UNITS METERS
END HEADER

`;

  // Grid export
  if (gridCells && gridCells.length > 0) {
    petrelContent += `# Grid Points
BEGIN POINTS
  INLINE XLINE X Y Z POROSITY PERMEABILITY
`;
    
    gridCells.forEach((cell, index) => {
      const inline = Math.floor(index / 100) + 1;
      const xline = (index % 100) + 1;
      
      petrelContent += `  ${inline} ${xline} ${cell.x.toFixed(precision)} ${cell.y.toFixed(precision)} ${cell.z.toFixed(precision)} ${(cell.porosity || 0).toFixed(precision + 2)} ${(cell.permeability || 0).toFixed(precision)}\n`;
    });
    
    petrelContent += 'END POINTS\n\n';
  }
  
  // Horizon export
  if (horizonData && horizonData.length > 0) {
    petrelContent += `# Horizon Surfaces
BEGIN HORIZONS
  X Y Z
`;
    
    horizonData.forEach(point => {
      petrelContent += `  ${point.x.toFixed(precision)} ${point.y.toFixed(precision)} ${point.z.toFixed(precision)}\n`;
    });
    
    petrelContent += 'END HORIZONS\n';
  }
  
  return petrelContent;
};

/**
 * Export data in Eclipse simulator format
 */
export const exportToEclipse = async (data, options) => {
  const { gridCells } = data;
  const { precision } = options;
  
  if (!gridCells || gridCells.length === 0) {
    throw new Error('No grid data available for Eclipse export');
  }
  
  // Calculate grid dimensions
  const uniqueX = [...new Set(gridCells.map(c => c.x))].sort((a, b) => a - b);
  const uniqueY = [...new Set(gridCells.map(c => c.y))].sort((a, b) => a - b);
  const uniqueZ = [...new Set(gridCells.map(c => c.z))].sort((a, b) => a - b);
  
  const nx = uniqueX.length;
  const ny = uniqueY.length;
  const nz = uniqueZ.length;
  
  let eclipseContent = `-- Eclipse Grid Export
-- Generated by Telesto Geological Grid Generator
-- Export Date: ${new Date().toISOString()}

RUNSPEC

DIMENS
  ${nx} ${ny} ${nz} /

GRID

-- Grid geometry
COORD
`;

  // Generate COORD data (corner points)
  for (let j = 0; j <= ny; j++) {
    for (let i = 0; i <= nx; i++) {
      const x = i < nx ? uniqueX[i] : uniqueX[nx - 1] + (uniqueX[1] - uniqueX[0]);
      const y = j < ny ? uniqueY[j] : uniqueY[ny - 1] + (uniqueY[1] - uniqueY[0]);
      
      eclipseContent += `  ${x.toFixed(precision)} ${y.toFixed(precision)} ${uniqueZ[0].toFixed(precision)}\n`;
      eclipseContent += `  ${x.toFixed(precision)} ${y.toFixed(precision)} ${uniqueZ[nz - 1].toFixed(precision)}\n`;
    }
  }
  eclipseContent += '/\n\n';
  
  // ZCORN data (cell corner depths)
  eclipseContent += 'ZCORN\n';
  const zcorn = [];
  
  for (let k = 0; k < nz; k++) {
    for (let j = 0; j < ny; j++) {
      for (let i = 0; i < nx; i++) {
        const z = uniqueZ[k];
        // 8 corner points per cell (top and bottom faces)
        for (let corner = 0; corner < 8; corner++) {
          zcorn.push(z.toFixed(precision));
        }
      }
    }
  }
  
  // Write ZCORN data in chunks of 8 values per line
  for (let i = 0; i < zcorn.length; i += 8) {
    eclipseContent += '  ' + zcorn.slice(i, i + 8).join(' ') + '\n';
  }
  eclipseContent += '/\n\n';
  
  // Properties
  if (gridCells.some(c => c.porosity !== undefined)) {
    eclipseContent += 'PORO\n';
    const porosityValues = [];
    
    for (let k = 0; k < nz; k++) {
      for (let j = 0; j < ny; j++) {
        for (let i = 0; i < nx; i++) {
          const cell = gridCells.find(c => 
            Math.abs(c.x - uniqueX[i]) < 0.1 && 
            Math.abs(c.y - uniqueY[j]) < 0.1 && 
            Math.abs(c.z - uniqueZ[k]) < 0.1
          );
          porosityValues.push((cell?.porosity || 0).toFixed(precision + 2));
        }
      }
    }
    
    for (let i = 0; i < porosityValues.length; i += 8) {
      eclipseContent += '  ' + porosityValues.slice(i, i + 8).join(' ') + '\n';
    }
    eclipseContent += '/\n\n';
  }
  
  if (gridCells.some(c => c.permeability !== undefined)) {
    eclipseContent += 'PERMX\n';
    const permValues = [];
    
    for (let k = 0; k < nz; k++) {
      for (let j = 0; j < ny; j++) {
        for (let i = 0; i < nx; i++) {
          const cell = gridCells.find(c => 
            Math.abs(c.x - uniqueX[i]) < 0.1 && 
            Math.abs(c.y - uniqueY[j]) < 0.1 && 
            Math.abs(c.z - uniqueZ[k]) < 0.1
          );
          permValues.push((cell?.permeability || 0).toFixed(precision));
        }
      }
    }
    
    for (let i = 0; i < permValues.length; i += 8) {
      eclipseContent += '  ' + permValues.slice(i, i + 8).join(' ') + '\n';
    }
    eclipseContent += '/\n\n';
    
    // PERMY and PERMZ (assume isotropic for simplicity)
    eclipseContent += 'PERMY\n';
    for (let i = 0; i < permValues.length; i += 8) {
      eclipseContent += '  ' + permValues.slice(i, i + 8).join(' ') + '\n';
    }
    eclipseContent += '/\n\n';
    
    eclipseContent += 'PERMZ\n';
    for (let i = 0; i < permValues.length; i += 8) {
      eclipseContent += '  ' + permValues.slice(i, i + 8).join(' ') + '\n';
    }
    eclipseContent += '/\n\n';
  }
  
  return eclipseContent;
};

/**
 * Export data in VTK format for visualization
 */
export const exportToVTK = async (data, options) => {
  const { gridCells, wellPaths } = data;
  const { precision } = options;
  
  if (!gridCells || gridCells.length === 0) {
    throw new Error('No grid data available for VTK export');
  }
  
  let vtkContent = `# vtk DataFile Version 3.0
Geological Grid Data
ASCII
DATASET UNSTRUCTURED_GRID

POINTS ${gridCells.length} float
`;

  // Write points
  gridCells.forEach(cell => {
    vtkContent += `${cell.x.toFixed(precision)} ${cell.y.toFixed(precision)} ${cell.z.toFixed(precision)}\n`;
  });
  
  // Write cells (assuming each point is a vertex)
  vtkContent += `\nCELLS ${gridCells.length} ${gridCells.length * 2}\n`;
  gridCells.forEach((_, index) => {
    vtkContent += `1 ${index}\n`;
  });
  
  // Write cell types (VTK_VERTEX = 1)
  vtkContent += `\nCELL_TYPES ${gridCells.length}\n`;
  gridCells.forEach(() => {
    vtkContent += '1\n';
  });
  
  // Write point data
  vtkContent += `\nPOINT_DATA ${gridCells.length}\n`;
  
  // Layer data
  vtkContent += 'SCALARS Layer int\nLOOKUP_TABLE default\n';
  gridCells.forEach(cell => {
    vtkContent += `${cell.layer}\n`;
  });
  
  // Porosity data
  if (gridCells.some(c => c.porosity !== undefined)) {
    vtkContent += '\nSCALARS Porosity float\nLOOKUP_TABLE default\n';
    gridCells.forEach(cell => {
      vtkContent += `${(cell.porosity || 0).toFixed(precision + 2)}\n`;
    });
  }
  
  // Permeability data
  if (gridCells.some(c => c.permeability !== undefined)) {
    vtkContent += '\nSCALARS Permeability float\nLOOKUP_TABLE default\n';
    gridCells.forEach(cell => {
      vtkContent += `${(cell.permeability || 0).toFixed(precision)}\n`;
    });
  }
  
  return vtkContent;
};

/**
 * Export data as JSON
 */
export const exportToJSON = async (data, options) => {
  const { precision } = options;
  
  // Round numerical values to specified precision
  const roundData = (obj) => {
    if (Array.isArray(obj)) {
      return obj.map(roundData);
    } else if (obj && typeof obj === 'object') {
      const rounded = {};
      for (const [key, value] of Object.entries(obj)) {
        if (typeof value === 'number') {
          rounded[key] = parseFloat(value.toFixed(precision));
        } else {
          rounded[key] = roundData(value);
        }
      }
      return rounded;
    }
    return obj;
  };
  
  return JSON.stringify(roundData(data), null, 2);
};

/**
 * Export data as GeoJSON
 */
export const exportToGeoJSON = async (data, options) => {
  const { horizonData, faultData, wellPaths } = data;
  const { precision } = options;
  
  const geojson = {
    type: 'FeatureCollection',
    features: []
  };
  
  // Add horizon data as points
  if (horizonData && horizonData.length > 0) {
    horizonData.forEach((point, index) => {
      geojson.features.push({
        type: 'Feature',
        geometry: {
          type: 'Point',
          coordinates: [
            parseFloat(point.x.toFixed(precision)),
            parseFloat(point.y.toFixed(precision)),
            parseFloat(point.z.toFixed(precision))
          ]
        },
        properties: {
          type: 'horizon',
          id: index,
          depth: parseFloat(point.z.toFixed(precision))
        }
      });
    });
  }
  
  // Add well paths as line strings
  if (wellPaths && wellPaths.length > 0) {
    wellPaths.forEach(well => {
      if (well.points && well.points.length > 0) {
        geojson.features.push({
          type: 'Feature',
          geometry: {
            type: 'LineString',
            coordinates: well.points.map(point => [
              parseFloat(point.x.toFixed(precision)),
              parseFloat(point.y.toFixed(precision)),
              parseFloat(point.z.toFixed(precision))
            ])
          },
          properties: {
            type: 'wellpath',
            name: well.name,
            totalDepth: parseFloat(well.totalDepth.toFixed(precision)),
            totalPoints: well.points.length
          }
        });
      }
    });
  }
  
  // Add fault data as multi-point features
  if (faultData && faultData.length > 0) {
    const faultGroups = {};
    faultData.forEach(point => {
      if (!faultGroups[point.segId]) {
        faultGroups[point.segId] = [];
      }
      faultGroups[point.segId].push(point);
    });
    
    Object.entries(faultGroups).forEach(([segId, points]) => {
      geojson.features.push({
        type: 'Feature',
        geometry: {
          type: 'MultiPoint',
          coordinates: points.map(point => [
            parseFloat(point.x.toFixed(precision)),
            parseFloat(point.y.toFixed(precision)),
            parseFloat(point.z.toFixed(precision))
          ])
        },
        properties: {
          type: 'fault',
          segmentId: segId,
          pointCount: points.length
        }
      });
    });
  }
  
  return JSON.stringify(geojson, null, 2);
};

/**
 * Generate export summary statistics
 */
export const generateExportSummary = (data, format, options) => {
  const { gridCells, wellPaths, horizonData, faultData } = data;
  
  let totalRecords = 0;
  let estimatedSize = 0; // in KB
  
  if (gridCells) {
    totalRecords += gridCells.length;
    estimatedSize += gridCells.length * 0.1; // ~100 bytes per grid cell
  }
  
  if (wellPaths) {
    const totalWellPoints = wellPaths.reduce((sum, well) => 
      sum + (well.points ? well.points.length : 0), 0);
    totalRecords += totalWellPoints;
    estimatedSize += totalWellPoints * 0.05; // ~50 bytes per well point
  }
  
  if (horizonData) {
    totalRecords += horizonData.length;
    estimatedSize += horizonData.length * 0.03; // ~30 bytes per horizon point
  }
  
  if (faultData) {
    totalRecords += faultData.length;
    estimatedSize += faultData.length * 0.04; // ~40 bytes per fault point
  }
  
  // Format-specific size adjustments
  switch (format) {
    case 'json':
    case 'geojson':
      estimatedSize *= 2; // JSON is more verbose
      break;
    case 'vtk':
      estimatedSize *= 1.5; // VTK has additional metadata
      break;
    case 'eclipse':
      estimatedSize *= 3; // Eclipse format is very verbose
      break;
  }
  
  return {
    totalRecords,
    totalSize: Math.round(estimatedSize),
    format,
    timestamp: new Date().toISOString()
  };
};